; -------------------------------------------------------------------------------------	;
;	Лабораторная работа №n по курсу Программирование на языке ассемблера				;
;	Вариант №1.8.																		;
;	Выполнил студент Максименко Дмитрий Сергеевич.										;
;																						;
;	Исходный модуль LabAssignment.asm													;
;	Содержит функции на языке ассемблера, разработанные в соответствии с заданием		;
; -------------------------------------------------------------------------------------	;
;	Задание: Реализовать прямое и обратное преобразования Фурье
;	Формат данных сигнала: __int16
;	Формат данных спектра: double
;	Размер (количество отсчетов) сигнала и спектра: 8
;	Способ реализации: DFT 2x2 + 2 бабочки
;	Отсчеты спектра являются комплексными числами. Причем действительные части хранятся
;	в первой половине массива, а мнимые - во второй

.DATA
;   Корни 8 степени из 1
    roots  real8  1., 0.70710678 , 0. , -0.70710678, -1., -0.70710678, 0., 0.70710678,                  ; вещественный части
			      0., -0.70710678, -1., -0.70710678,  0., 0.70710678 , 1., 0.70710678                   ; мнимые части

;   Корни 4 степени из 1
	forthroots real8    1., 0. , -1., 0. ,
	                    0., -1.,  0., 1.
;   Матрица преобразования, она же для обратного
	matrix       dw 1, 1, 1, -1
;   Количество отсчтеов сигнала
	signal_size  dw 8


.CODE
; -------------------------------------------------------------------------------------	;
; void CalculateSpectrum(spectrum_type* Spectrum, signal_type* Signal)					;
;	Прямое преобразование Фурье. Вычисляет спектр Spectrum по сигналу Signal			;
;	Типы данных spectrum_type и signal_type, а так же разимер сигнала					;
;	определяются в файле Tuning.h														;
; -------------------------------------------------------------------------------------	;
CalculateSpectrum PROC	; [RCX] - Spectrum
						; [RDX] - Signal
	
	push rbp
	push rcx
	sub rsp, 16              ; место для хранения результата первого шага
	push rdx

	mov rbp, rsp                                ;
	and  sp, 0FFE0h                             ; выравнивание указателя на 32 бита

	;*************      умножаем вектора на матрицу     ***************
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov rcx, [rbp]
	lea rdx, matrix
	mov r9, rbp 
	add r9, 8
	call MultiplyVectorOnMatrix
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov rcx, [rbp]
	add rcx, 2
	lea rdx, matrix
	mov r9, rbp 
	add r9, 12
	call MultiplyVectorOnMatrix
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov rcx, [rbp]
	add rcx, 4
	lea rdx, matrix
	mov r9, rbp 
	add r9, 16
	call MultiplyVectorOnMatrix
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    mov rcx, [rbp]
	add rcx, 6
	lea rdx, matrix
	mov r9, rbp 
	add r9, 20
	call MultiplyVectorOnMatrix
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	add rbp, 8    ; убираем из стека указатель на сигнал, тк все необходимые значения в массиве first_step_res
	              ; теперь стек содержит результат первого шага и dst 
	finit

	sub rsp, 64                                 ; освобождаем место для хранения чисел в 64 битной форме


	;----------------------------Перезаписываем в память, в виде 64 битных чисел с плавающей точкой------------------------------------

	mov rcx, 8                             ;  количество повторов
	mov rax, rbp                           ;  src
	mov r8 , rsp                           ;  dst

start_loop_rewrite:      
	    fild  word  ptr [rax]              ; загрузили 16 битное целое число
	    fstp  qword ptr [r8]               ; сохранили результат, как целое 16 битное число

		dec rcx

		cmp cx, 0
		je end_loop_rewrite
		add rax, 2                         ; сдвиг в src на один элемент int16
		add r8 , 8                         ; сдвиг в dst на один элемент real8
		jmp start_loop_rewrite

end_loop_rewrite:


    sub rsp, 128                                 ; освобождаем место для хранения результата первого шага


	; vpmovsxwq  xmm0, dword ptr [rbp]            ; загружаем 2 первых числа на ymm0
	 ;vpmovsxwq  xmm1, dword ptr [rbp + 4]        ;
	; vperm2f128 ymm0, ymm0, ymm0, 6              ;
	; vpmovsxwq  xmm1, dword ptr [rbp + 8]        ; загружаем 2 вторых числа на ymm1
	; vpmovsxwq  xmm2, dword ptr [rbp + 12]       ;
	; vperm2f128 ymm1, ymm1, ymm1, 6              ; 

	add rbp, 16                                  ; удаляем элементы, записанные в 16 битной форме

;----------------------Первая бабочка: нам нужна вещественная и комплексная часть -----------------------------
	 lea rbx, forthroots
;--------------Вещественная часть------------------------------------------------------------------------------

    vbroadcastf128 ymm0, xmmword ptr [rsp + 128]         ;      вещественные части первых элементов
	vbroadcastf128 ymm1, xmmword ptr [rsp + 160]         ;      вещественные части вторых элементов
	 vmovdqa        ymm3, ymmword ptr [rbx]               ;      вещественные части корней 

	 vmulpd         ymm3, ymm1, ymm3                      ;      вещественное второго элемента на вещественное корня 
	 vaddpd         ymm3, ymm0, ymm3                      ;
	                                                      ;      получаем общую вещественную часть, записываем ее в память.
     vmovapd  ymmword ptr [rsp], ymm3                     ;      записываем в память
	  
;-------------Комплексная часть---------------------------------------------------------------------------------

	 vbroadcastf128 ymm0, xmmword ptr [rsp + 160]         ;      вещественные части вторых элементов
	 vmovdqa        ymm4, ymmword ptr [rbx + 32]          ;      комплексные части корней
	 vmulpd         ymm0, ymm0, ymm4                      ;      вещественная вторых на комплексные корней
     vmovapd        ymmword ptr [rsp + 64], ymm0          ;      записываем в память


;----------------------Вторая бабочка: нам нужна вещественная и комплексная часть -----------------------------
;--------------Вещественная часть------------------------------------------------------------------------------

     vbroadcastf128 ymm0, xmmword ptr [rsp + 144]         ;      вещественные части первых элементов
	 vbroadcastf128 ymm1, xmmword ptr [rsp + 176]         ;      вещественные части вторых элементов
	 vmovdqa        ymm3, ymmword ptr [rbx]               ;      вещественные части корней 
	 vmovdqa        ymm4, ymmword ptr [rbx + 32]          ;      комплексные части корней
	 vmulpd         ymm1, ymm1, ymm3                      ;      вещественное второго элемента на вещественное корня
	 vaddpd         ymm0, ymm0, ymm1                      ;
	                                                      ;      получаем общую вещественную часть, записываем ее в память.
     vmovapd  ymmword ptr [rsp + 32], ymm0                ;      записываем в память
	  
;-------------Комплексная часть---------------------------------------------------------------------------------


	 vbroadcastf128 ymm0, xmmword ptr [rsp + 176]         ;      вещественные части вторых элементов
	 vmulpd         ymm0, ymm0, ymm4                      ;      вещественная вторых на комплексные корней
     vmovapd  ymmword ptr [rsp + 96], ymm0                ;      записываем в память


	 
	 ;-----------------------------Большая бабочка, вещественную и комплексную часть---------------------------------
	
	;-----------------------Верхняя половина большой бабочки---------------------------------------------------------
	;---------------Вещественная часть-------------------------------------------------------------------------------
	lea            rbx , roots                           ;      корни 8-ой степени из 1
	mov            rax , rsp                             ;      src
    mov            r8  , [rbp]                           ;      dst

	vmovdqa        ymm0, ymmword ptr [rax]               ;      вещественная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rbx]               ;      вещественная корней 
	vmulpd         ymm1, ymm1, ymm2                      ;      вещественная вторых на вещественную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с вещественной частью первых элементов

	vmovdqa        ymm1, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 64]          ;      комплексная корней
	vmulpd         ymm1, ymm1, ymm2                      ;      комплексная вторых на косплексную корней
	vsubpd         ymm0, ymm0, ymm1                      ;      вычитаем, тк в произведении комплексных частей i^2 = -1
	 
	vmovdqa        ymmword ptr [r8], ymm0                ;      записываем в память

	;---------------Комплексная часть--------------------------------------------------------------------------------

	vmovdqa        ymm0, ymmword ptr [rax + 64]          ;      комплексная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm3, ymmword ptr [rbx]               ;      вещественная корней 
	vmovdqa        ymm4, ymmword ptr [rbx + 64]          ;      комплексная корней
	vmulpd         ymm1, ymm1, ymm4                      ;      вещественная вторых на комплексную корней
	vmulpd         ymm2, ymm2, ymm3                      ;      компклексная вторых на вещественную корней

	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с комплексной частью первых элементов
	vaddpd         ymm0, ymm0, ymm2                      ;      
	 
	vmovdqa        ymmword ptr [r8 + 64], ymm0           ;      записываем в память


	;-----------------------Нижняя половина большой бабочки----------------------------------------------------------
	;---------------Вещественная часть-------------------------------------------------------------------------------
	vmovdqa        ymm0, ymmword ptr [rax]               ;      вещественная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 32]          ;      вещественная корней, начиная с 5-го корня
	vmulpd         ymm1, ymm1, ymm2                      ;      вещественная вторых на вещественную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с вещественной частью первых элементов

	vmovdqa        ymm1, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 96]          ;      комплексная корней, начиная с 5-го корня
	vmulpd         ymm1, ymm1, ymm2                      ;      комплексная вторых на косплексную корней
	vsubpd         ymm0, ymm0, ymm1                      ;      вычитаем, тк в произведении комплексных частей i^2 = -1
	
	vmovdqa        ymmword ptr [r8 + 32], ymm0           ;      записываем в память

	;---------------Комплексная часть--------------------------------------------------------------------------------

	vmovdqa        ymm0, ymmword ptr [rax + 64]          ;      комплексная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm3, ymmword ptr [rbx + 32]          ;      вещественная корней, начиная с 5-го корня
	vmovdqa        ymm4, ymmword ptr [rbx + 96]          ;      комплексная корней, начиная с 5-го корня
	vmulpd         ymm1, ymm1, ymm4                      ;      вещественная вторых на комплексную корней
	vmulpd         ymm4, ymm2, ymm3                      ;      компклексная вторых на вещественную корней

	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с комплексной частью первых элементов
	vaddpd         ymm0, ymm0, ymm4                      ;      
	 
	vmovdqa        ymmword ptr [r8 + 96], ymm0           ;      записываем в память

	vzeroall
	add rbp, 8                            ; удаляем из стека указатель на src
	mov rsp, rbp                          ; возвращаем стек в первоначальную форму
	mov rbp, [rsp]                        ; восстанавливаем rbp
	add rsp, 8                            ; удаляем из rsp rbp

	ret
CalculateSpectrum ENDP
; -------------------------------------------------------------------------------------	;
; void RecoverSignal(signal_type* Signal, spectrum_type* Spectrum)						;
;	Обратное преобразование Фурье. Вычисляет сигнал Signal по спектру Spectrum			;
;	Типы данных spectrum_type и signal_type, а так же размер сигнала					;
;	определяются в файле Tuning.h														;
; -------------------------------------------------------------------------------------	;
RecoverSignal PROC	; [RCX] - Signal
					; [RDX] - Spectrum
	finit

	push rcx
	sub rsp, 160                                ; место для результата первого шага + 32 бита на выравнивание
	mov rax, rsp                                ; 
	add rax, 32
	and  ax, 0FFE0h                             ; выравнивание указателя на 32 бита

	;**************         цикл умножения векторов на матрицы            *************
	                                            ;  rdx - src по условию
	mov rcx, 4                                  ;  количество повторов        
	mov r8,  rax                                ;  dst
	lea r9,  matrix                             ;  матрица, на которую производится умножение

	;vmovapd ymm0, ymmword ptr [rdx]             ;  вещественные части, первых 4 элемента
	;vmovapd ymm1, ymmword ptr [rdx + 32]        ;  вещественные части, последних 4 элементов
	
	;vaddpd ymm2, ymm0, ymm1                     ;  вещественная часть первых элементов 
	;vmovapd [r8], ymm4                          ;  записываем в память
	;vsubpd ymm3, ymm0, ymm1                     :  вещественная часть вторых элементов
	;vmovapd [r8 + 32], ymm4                     ;  записываем в память

	;vmovapd ymm0, ymmword ptr [rdx + 64]        ;  мнимые части, первых 4 элемента
	;vmovapd ymm1, ymmword ptr [rdx + 96]        ;  мнимые части, последних 4 элементов

	;vaddpd ymm2, ymm0, ymm1                     ;  мнимая часть первых элементов 
	;vmovapd [r8 + 64], ymm4                     ;  записываем в память
	;vsubpd ymm3, ymm0, ymm1                     :  мнимая часть вторых элементов
	;vmovapd [r8 + 96], ymm4                     ;  записываем в память

	                                            ;  теперь в памяти x00, x10, x20, x30,          x01, x11, x21, x31      так лежат вещественная, а затем комплексная часть
												;  хотим           x00, x01, x10, x11,          x20, x21, x30, x31 

	
 
start_loop_rev:
	;  |1 1| (x + ki) = (x + y + ki + li)
	;  |1 -1| (y + li) = (x - y + ki - li)
	;
	;;;;;;;;;;;;;;;;;;;;;;;;     вещественная часть первого элемента ответа     ;;;;;;;;;;;;;;;;;;;;;;;;
	fild  word  ptr[r9]           ; a
	fld   qword ptr[rdx]          ; x
	fmulp                         ; ax
	fild  word ptr[r9 + 2]        ; b
	fld   qword ptr[rdx + 32]     ; y
	fmulp                         ; by
	faddp                         ; ax + by
	fstp  qword ptr[r8]           ; записываем результат

	;;;;;;;;;;;;;;;;;;;;;;;      мнимая часть первого элемента ответа         ;;;;;;;;;;;;;;;;;;;;;;;;

	fild  word ptr[r9]            ; a
	fld   qword ptr[rdx + 64]     ; k
	fmulp                         ; ak
	fild  word ptr[r9 + 2]        ; b
	fld   qword ptr[rdx + 96]     ; l
	fmulp                         ; bl
	faddp                         ; ak + bl
	fstp  qword ptr[r8 + 64]      ; записываем результат
	
	;;;;;;;;;;;вещественная часть второго элемента ответа;;;;;;;;;;;;;;;;;;;;;;;;
	fild  word  ptr[r9 + 4]       ; c
	fld   qword ptr[rdx]          ; x
	fmulp                         ; cx
	fild  word  ptr[r9 + 6]       ; d
	fld   qword ptr[rdx + 32]     ; y
	fmulp                         ; dy
	faddp                         ; cx + dy
	fstp  qword ptr[r8 + 8]       ; записываем результат
	;;;;;;;;;;;мнимая часть второго элемента ответа;;;;;;;;;;;;;;;;;;;;;;;;
	fild  word  ptr[r9 + 4]       ; c
	fld   qword ptr[rdx + 64]     ; k
	fmulp                         ; ck
	fild  word  ptr[r9 + 6]       ; d
	fld   qword ptr[rdx + 96]     ; l
	fmulp                         ; dl
	faddp                         ; ck + dl
	fstp  qword ptr[r8 + 72]      ; записываем результат


	dec rcx
	cmp rcx, 0
	je end_loop_rev
	add rdx, 8                    ; сдвиг в src на один элемент real8
	add r8, 16                    ; сдвиг в dst на два элемента real8, тк мы записали два элемента вектора
	jmp start_loop_rev
end_loop_rev:


    sub rax, 128                  ; место для результата второго шага, а также дополнительные 32 бита на выравнивание указателя
	                              ; нам нужно одновременно хранить результат первого и второго шага,
	                              ; а также указатель на запись финального результата, поэтому стек занимает до 264 байт 
	sub rsp, 128
    
	;----------------------Первая бабочка: нам нужна только вещественная часть -----------------------------

	 lea rbx, forthroots
	 vbroadcastf128 ymm0, xmmword ptr [rax + 128]         ;      вещественные части первых элементов
	 vbroadcastf128 ymm1, xmmword ptr [rax + 160]         ;      вещественные части вторых элементов
	 vbroadcastf128 ymm2, xmmword ptr [rax + 224]         ;      комплексные части вторых элементов
	 vmovdqa        ymm3, ymmword ptr [rbx]               ;      вещественные части корней 
	 vmovdqa        ymm4, ymmword ptr [rbx + 32]          ;      комплексные части корней
	 vmulpd         ymm1, ymm1, ymm3                      ;      вещественное второго элемента на вещественное корня
	 vmulpd         ymm2, ymm2, ymm4                      ;      комплексное второго элемента на комплексное корня 
	 vaddpd         ymm0, ymm0, ymm1                      ;
	 vaddpd         ymm0, ymm0, ymm2                      ;      один минус тк i^2 = -1, и один минус из комплексного сопряжения корня
	                                                      ;      получаем общую вещественную часть, записываем ее в память.

     vmovapd  ymmword ptr [rax], ymm0                     ;      записываем в память
	 

;----------------------Вторая бабочка: нам нужна вещественная и комплексная часть -----------------------------
;--------------Вещественная часть------------------------------------------------------------------------------

     vbroadcastf128 ymm0, xmmword ptr [rax + 144]         ;      вещественные части первых элементов
	 vbroadcastf128 ymm1, xmmword ptr [rax + 176]         ;      вещественные части вторых элементов
	 vbroadcastf128 ymm2, xmmword ptr [rax + 240]         ;      комплексные части вторых элементов
	 vmovdqa        ymm3, ymmword ptr [rbx]               ;      вещественные части корней 
	 vmovdqa        ymm4, ymmword ptr [rbx + 32]          ;      комплексные части корней
	 vmulpd         ymm1, ymm1, ymm3                      ;      вещественное второго элемента на вещественное корня
	 vmulpd         ymm2, ymm2, ymm4                      ;      комплексное второго элемента на комплексное корня 
	 vaddpd         ymm0, ymm0, ymm1                      ;
	 vaddpd         ymm0, ymm0, ymm2                      ;      один минус тк i^2 = -1, и один минус из комплексного сопряжения корня
	                                                      ;      получаем общую вещественную часть, записываем ее в память.
     vmovapd  ymmword ptr [rax + 32], ymm0                ;      записываем в память

;-------------Комплексная часть---------------------------------------------------------------------------------


	 vbroadcastf128 ymm0, xmmword ptr [rax + 176]         ;      вещественные части вторых элементов
	 vbroadcastf128 ymm1, xmmword ptr [rax + 240]         ;      комплексные части вторых элементов

	 vmulpd         ymm0, ymm0, ymm4                      ;      вещественная вторых на комплексные корней
	 vmulpd         ymm1, ymm1, ymm3                      ;      комплексные вторых на вещественные корней
	 vsubpd         ymm0, ymm1, ymm0                      ;      минус из-за комплексного сопряжения корня

	 vbroadcastf128 ymm1, xmmword ptr [rax + 208]         ;      комплексные части первых элементов
	 vaddpd         ymm0, ymm1, ymm0                      ;      складываем с комплексной частью первых элементов

     vmovapd  ymmword ptr [rax + 96], ymm0                ;      записываем в память


;-----------------------------Большая бабочка, считаем только вещественную часть---------------------------------
	lea            rbx , roots

	vmovdqa        ymm0, ymmword ptr [rax]               ;      вещественная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rbx]               ;      вещественная корней 
	vmulpd         ymm1, ymm1, ymm2                      ;      вещественная вторых на вещественную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с вещественной частью первых элементов

	vmovdqa        ymm1, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 64]          ;      комплексная корней
	vmulpd         ymm1, ymm1, ymm2                      ;      комплексная вторых на косплексную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем, тк в произведении комплексных частей i^2 = -1, а также корень сопряжен
	 
	vmovdqa        ymmword ptr [rax + 128], ymm0         ;      записываем в память

	vmovdqa        ymm0, ymmword ptr [rax]               ;      вещественная первых элементов
	vmovdqa        ymm1, ymmword ptr [rax + 32]          ;      вещественная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 32]          ;      вещественная корней, начиная с 5-го корня
	vmulpd         ymm1, ymm1, ymm2                      ;      вещественная вторых на вещественную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем с вещественной частью первых элементов

	vmovdqa        ymm1, ymmword ptr [rax + 96]          ;      комплексная вторых
	vmovdqa        ymm2, ymmword ptr [rbx + 96]          ;      комплексная корней, начиная с 5-го корня
	vmulpd         ymm1, ymm1, ymm2                      ;      комплексная вторых на косплексную корней
	vaddpd         ymm0, ymm0, ymm1                      ;      складываем, тк в произведении комплексных частей i^2 = -1, а также корень сопряжен
	
	vmovdqa        ymmword ptr [rax + 160], ymm0         ;      записываем в память


;----------------------------Перезаписываем в память, как надо, а также делим на 8----------------------------------------

	mov rcx, 8                             ;  количество повторов
	add rax, 128                           ;  src
	mov r8 , [rsp + 288]                   ;  dst

start_loop_third_rev:      
	    fld  qword ptr [rax]               ; загрузили 64 битное число
		fidiv signal_size
	    fistp word ptr [r8]                ; сохранили результат, как целое 16 битное число

		dec rcx

		cmp cx, 0
		je end_loop_third_rev
		add rax, 8                         ; сдвиг в src на один элемент real8
		add r8 , 2                         ; сдвиг в dst на один элемент int16
		jmp start_loop_third_rev

end_loop_third_rev:
	
	vzeroall
	add rsp, 296                           ; очищаем стек

	ret
RecoverSignal ENDP



MultiplyVectorOnMatrix  PROC   ; [RCX] - beginining of Vector 2x1
							   ; [RDX] - Matrix 2x2
							   ; R9 - Pointer to result array
	;  |a b| (x) = (ax + by)
	;  |c d| (y) = (cx + dy)
	;
	movsx    r10w ,  byte ptr [rdx]                         ; a
	movsx    eax  ,  byte ptr [rcx]                         ; x
	imul     r10w ,  ax                                     ; ax
	movsx    r11w ,  byte ptr [rdx + 2]                     ; b
	movsx    r8w  ,  byte ptr [rcx + 8]                     ; y
	imul     r11w ,  r8w                                    ; by
	add      r10w ,  r11w                                   ; ax + by
	mov      [r9] ,  r10w                                   ; запись первого элемента вектора

	movsx    r10w ,  byte ptr[rdx + 4]                      ; c
	imul     r10w ,  ax                                     ; cx
	movsx    r11w ,  byte ptr[rdx + 6]                      ; d
	imul     r11w ,  r8w                                    ; dy
	add      r10w ,  r11w                                   ; cx + dy

	mov      [r9 + 2]  ,  r10w                              ; запись второго элемента вектора
	ret

MultiplyVectorOnMatrix  ENDP
END	 

